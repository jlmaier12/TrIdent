---
title: "TrIdent"
author: "Jessie Maier & Jorden Rabasco"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
description: >
  TrIdent (Transduction Identification) is a reference-independent tool for the automated detection, classification and characterization of transduction events in metagenomic sequence data. With only three functions, TrIdent is fast and user-friendly. Learn how to use TrIdent with a sample dataset here. 
vignette: >
  %\VignetteIndexEntry{Using TrIdent}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 9,
  fig.asp = 0.8,
  out.width = "80%",
  collapse = TRUE,
  comment = "##"
)
```

```{r setup, echo=FALSE, warning=FALSE}
library(TrIdent)
library(knitr)
library(patchwork)
library(ggplot2)
```

# Introduction

### **TrIdent**- **Tr**ansduction **Ident**ification

TrIdent is a reference-independent bioinformatics tool that automates the analysis of transductomics data by automatically detecting, classifying and characterizing potential transducing events in read coverage data. Transductomics is a DNA-sequencing based method for the detection and characterization of transduction events. Developed by Kleiner et al. (2020), transductomics relies on mapping reads from a virome (VLP-fraction) of a sample to contigs assembled from the metagenome (whole-community) of the same sample. Reads from bacterial DNA carried by viruses and other VLPs (Virus-like particles) will map back to the bacterial contigs of origin creating read coverage patterns indicative of potential ongoing transduction.

**Reference:** Kleiner, M., Bushnell, B., Sanderson, K.E. et al. Transductomics: sequencing-based detection and analysis of transduced DNA in pure cultures and microbial communities. Microbiome 8, 158 (2020). <https://doi.org/10.1186/s40168-020-00935-5>

TrIdent consists of three main functions to automatically detect, classify, and characterize potential transducing events:

-   `TrIdentClassifier()`: Classifies contigs as 'Prophage-like', 'Sloping', 'HighCovNoPattern', and 'NoPattern' using pattern-matching
-   `plotTrIdentResults()`: Plots pattern-matching results of `TrIdentClassifier()`
-   `specializedTransductionID()`:  searches contigs classified as Prophage-like by `TrIdentClassifier()` for potential specialized transduction

# Installation

## BioConductor install
```{r, eval=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("TrIdent")
library(TrIdent)
```

## GitHub install
```{r, eval=FALSE}
if (!require("devtools", quietly = TRUE))
    install.packages("devtools")

devtools::install_github("jlmaier12/TrIdent", ref="master")
library(TrIdent)
```


# Input Data

## Transductomics data
Transductomics allows for a glimpse into the 'transductome' (i.e the DNA being transduced) in a microbiome sample be identifying the bacterial DNA being actively carried by viral-like particles (VLPs). A transductomics dataset consists of two parts- a whole-community fraction and a VLP-fraction. The whole-community fraction is generated by extracting and sequencing DNA from the whole sample. The VLP-fraction is generated by first separating and ultra purifying the VLPs from the sample followed by DNA extraction and sequencing. Sequencing reads from the whole-community fraction are assembled and then both the whole-community and VLP-fraction reads are mapped to the assembly. **Read mapping should be performed using a high minimum identity (0.97 or higher) and random mapping of ambiguous reads.**  The pileup files needed for TrIdent are generated using using bam files produced during read mapping. More information on pileup files below. 

### Example transductomics data generation workflow:
Generating transductomics data from a conventional mouse fecal metagenome: 
- Homogenized feces represents the whole-community. 
- The VLP-fraction of the fecal homogenate is separated with 0.2um filtration to remove bacterial cells, treated with DNase to remove free DNA and purified via CsCl density gradient ultracentrifugation. 
- Both the whole-community and VLP-fraction are sequenced with Illumina (paired-end mode, 150 bp reads).
- Sequencing reads are decontaminated from host sequences and trimmed to remove adapters and low quality sequences.
- The metagenome is assembled from the whole-community reads and filtered to remove contigs less that 30,000 bp (min. contig size for TrIdent).
- The whole-community and VLP-fraction raw reads are mapped to the metagenome contigs to create two separate bam files
- bam files are used to create two pileup txt files

Note- Specific sequencing requirements are needed for transductomics! Sample preparation and sequencing procedures are detailed in Kleiner et al. (2020).

## Pileup files
A pileup file is a file format that consists of ***. We take advantage of the fact that pileup files can be used to generate a rolling mean of read coverages and associated base pair positions across every contig in a metagenome, effectively summarizing the read coverage patterns across contigs while reducing the size of the data.  

Some read mappers, like BBMap, will allow for the generation of pileup files in the bbmap.sh command with the use of the bincov output. Otherwise, SAMtools pileup can convert bam files produced by any read mapper to pileup functions compatible with TrIdent. The more 

TrIdent classifies mapped read coverage patterns using a novel pattern-matching algorithm that operates on pileup files. Pileup files are generated through read mapping and containg a rolling mean of read coverages and associated base pair positions for every contig in a metagenome assembly. TrIdent requires two pileup files:

- a VLP-fraction pileup: Sequencing reads from a sample's VLP-fraction mapped to a metagenome assembly from the same sample.
- a whole-community pileup: Sequencing reads from a sample's whole-community mapped to the metagenome of the same sample. 

**The data used for each pileup file must originate from the same sample. Pileup files must use a 100 bp window/bin size for the rolling mean.** 

Here is what the pileup file format should look like. The information in the first column may be formatted differently depending on your contig accession format:
```{r echo=FALSE}
data(WholeCommunitySamplePileup)
data(VLPFractionSamplePileup)
print(head(VLPFractionSamplePileup), row.names=FALSE)
```

TrIdent has built-in data cleaning and reformatting. **If you do not use BBMap's `pileup.sh` to generate the pileup files, then you are responsible for data-cleaning and reformatting.** Your pileup files must be in the following format (same column names, same column classes, etc.) and you must use the `cleanup=FALSE` argument for the `TrIdent_classifier()`, `Plot_TrIdentPatternMatches()`, and `SpecializedTransduction_ID()`.
```{r, echo=FALSE}
data(CleanVLPFractionSamplePileup)
print(head(CleanVLPFractionSamplePileup), row.names=FALSE)
```

# Quick Start

Here is how to run TrIdent with default parameters. TrIdent involves the use of three functions that are used in the following order:
```{r}
TrIdentOutput <- TrIdentClassifier(VLPpileup=VLPFractionSamplePileup, WCpileup=WholeCommunitySamplePileup)
```

```{r}
TrIdentPlots <- plotTrIdentResults(VLPpileup=VLPFractionSamplePileup, WCpileup=WholeCommunitySamplePileup, TrIdentResults=TrIdentOutput)
TrIdentPlots
```

```{r}
SpecTransduction <- specializedTransductionID(VLPpileup=VLPFractionSamplePileup, TrIdentResults=TrIdentOutput)
SpecTransduction
```


# TrIdentClassifier()

`TrIdentClassifier()`  is the main function in TrIdent. This function cleans and reformats your input data, filters contigs based on length and read coverage, performs pattern-matching to classify contigs, identifies active/highly abundant and heterogenously integrated prophage-like elements, determines which contigs have high VLP-fraction:whole-community read coverage ratios, identifies start and stop positions and sizes of pattern matches, calculates slopes for Sloping pattern matches, generates a pattern-match quality score and outputs all information in a neat summary table.

`TrIdentClassifier()` features:

1.  **Contig filtering:**

    Contigs are filtered out based on short length or low read coverage. TrIdent filters out contigs that do not have at least 10x coverage on a total of 5000 bp across the whole contig due to insufficient read coverage. Contigs where the 50th greatest coverage value is less than 10 means that there is no region on the contig with read coverages greater than 10 for at least 5,000bp. The low read coverage filtering was done in this way to avoid filtering out long contigs with short Prophage-like patterns that might get removed if filtering was done with averages or medians. Additionally, contigs less than 30 kbp are filtered out by default, however this can be changed with the MinContigLength parameter. Contigs shorter than 30 kbp may be poor quality and are not big enough to show clear transduction patterns. If you would like to speed-up processing time of TrIdent, consider pre-filtering your assembly for contigs greater than 30 kbp!

2.  **Pattern-matching:**
    TrIdent uses predefined patterns which correspond to various mechanisms of transduction. The patterns are built using the
specific length and read coverage values of the contig being assessed. Patterns are translated across each contig and at each
translation, a match-score is calculated by taking the mean absolute difference of the VLP-fraction read coverage and the
pattern values. The smaller the match-score, the better the pattern-match. After a pattern is fully translated across a
contig, certain aspects of the pattern are changed (i.e. height, width, slope) and translation is repeated. This process of
translation and pattern re-scaling is repeated until a wide variety of height, width and slope combinations are tested for
each pattern variation. After pattern-matching is complete, the pattern associated with the best match-score is used for
contig classification. Contigs are classified as ‘Prophage-like’, ‘Sloping’, ‘HighCovNoPattern' or 'NoPattern'. 

    
    Contigs that are not filtered out proceed to pattern-matching where they are matched with a variety of patterns representing transduction events. Patterns are ‘built’ and the x and y-axis values are scaled specific to the characteristics of each contig to ensure the pattern-matching is data agnostic. After a pattern is built, it is translated across the contig being assessed, and the mean absolute difference in coverage (match-score) between the contig and the pattern is calculated at each translation. Theoretically, if a pattern is a perfect match to the coverages on a contig, then taking the mean absolute difference in y-axis values will result in a 0. Obviously, no pattern will be a perfect match to a contig, but the closer to 0 the match-score is, the better that pattern matches the read coverage pattern on the contig. The contig is classified based on the pattern that achieves the lowest match-score.

## Patterns

-   **Sloping:** There are four sloping pattern variations in the Gen/Lat/GTA class. The sloping pattern is representative of generalized, lateral and gene transfer agents due to the decreasing frequency of DNA packaging moving away from the packaging initiation sites. All patterns are built to the same length at the contig being assessed. The peak of the slope starts slightly above the contigs' maximum coverage value and the base of the slope starts at the contig's minimum coverage value. The slopes are decreased until a minimum slope of 0.0001 (change of 10 read coverage values over 100,000bp) is reached. Generalized, lateral and gene transfer agent transduction events can span many kbps of DNA and a single contig typically does not capture the entire event. Depending on which part of the transducing event is captured by the contig, the sloping can be very severe or almost 0. Patterns 1 and 2 represent contigs that capture a Gen/Lat/GTA transducing event somewhere in the middle. Patterns 2 and 4 represent contigs that capture the packagining initiation of a Gen/Lat/GTA transducing event. Patterns 2 and 4 are translated across the contig in addition to having the slopes changed while only the slopes are changed on patterns 1 and 2.

```{r echo=FALSE}

dataframe <- cbind.data.frame(c(1:100), c(seq(1,100,1)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL, title="Pattern 1")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(seq(100,1,-1)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot2 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL,title="Pattern 2")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(rep(0,20),seq(80,1,-1)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot3 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL, title="Pattern 3")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
  )

dataframe <- cbind.data.frame(c(1:100), c(seq(1,80,1), rep(0,20)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot4 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
  labs(x=NULL,y=NULL, title="Pattern 4")+
  theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )


plot1+plot2+plot3+plot4
```

-   **Prophage-like:**

There are three patterns in the Prophage-like class. The block pattern is representative of the prophage or phage-inducible chromosomal islands (PICIs) reads mapping back to their respective integration sites in the host bacterium's chromosome. The block patterns are built to the same length at the contig being assessed. The top of the block starts at the contig's maximum coverage value while the base starts at the contig's minimum coverage value. The block width starts close to the length of the contig. The block heights are decreased followed by the block's width to ensure a variety of block height/width combinations are tested. Each pattern variation is translated across the contig. The blocks widths never get smaller than 10kbp. Pattern 1 represents a prophage/PICI that is entirely on the contig while patterns 2 and 3 repesent a prophage/PICI that trails off the right or left side of the contig, respectively.

```{r echo=FALSE}
dataframe <- cbind.data.frame(c(1:100), c(rep(0,20), rep(100,60), rep(0,20)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL,title="Pattern 1")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(rep(0,60), rep(100,40)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot2 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL,title="Pattern 2")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(rep(100,40), rep(0,60)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot3 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL, title="Pattern 3")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

plot1+plot2+plot3
```

-   **No pattern:**

There is one pattern in the None class. In order to know if the match score generated for a Gen/Lat/GTA or Prophage-like pattern match on a specific contig is 'good', we need a baseline match score to compare to. A contig without a Prophage-like or Gen/Lat/GTA pattern is likely to have fairly even read coverage across the contig which the None pattern tries to match. If the contig truely does have a Prophage-like or Gen/Lat/GTA pattern, its match score to the none score is likely to be worse than the match score to the pattern it truely matches. The pattern is built to the length of the contig being assessed and is simply the mean coverage of the contig.

```{r echo=FALSE}
dataframe <- cbind.data.frame(c(1:100), rep(10,100))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
  ylim(0,100)+
    labs(x=NULL,y=NULL, title="Pattern 1")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

plot1
```

-------------------------------------------------------------------------------------------------------------------------------------------

3.  **Identifying highly active/abundant prophage/PICIs:**

    A prophage or PICI that is actively replicating or exists in high abundance in the environment will likely generate more reads than its respective host bacterium. This may create a region of elevated read coverage at the prophage/PICI insertion site in the whole-community fraction. This phenomenome has been previously studied by the Anantharaman lab and was used to produce their bioinformatics tool- PropagAtE. Since TrIdent locates prophage/PICIs as part of its pattern-matching, we can use the genomic coordinates to see if the associated prophage/PICI region has elevated read coverage in the whole-community fraction. Contigs where the prophage/PICI:non-prophage/PICI region has a mean read coverage ratio of greater than 1.3 are labeled highly active/abundant. If the non-prophage/PICI region is less than 20,000 bp, then the contig is labeled as 'CBD' (Can't Be Determined) as its difficult to determine if the prophage/PICI region is truely elevated when there is so little non-prophage/PICI region to compare to.

    **Reference**: Kieft K, Anantharaman K. Deciphering Active Prophages from Metagenomes. mSystems. 2022 Apr 26;7(2):e0008422. doi: 10.1128/msystems.00084-22. Epub 2022 Mar 24. PMID: 35323045; PMCID: PMC9040807.

4.  **Identifying contigs with high VLP-fraction:whole-community read coverages:**

    Contigs that are classified as None by pattern-matching are assessed to see if they have high VLP-fraction:Whole-community median read coverage ratios. As mentioned in the pattern-matching section for generalized/lateral/gene transfer agent transduction events above, depending on which part of the sloping read coverage pattern is captured by a contig, the sloping can vary from being very severe to almost non-existent. Typically the 'tails' of sloping events have very little to no slope, but still represent transduction events. To try to differentiate contigs classified as None that represent 'tails' of Gen/Lat/GTA transduction events and those that truely represent no transduction, we are using the median read coverage ratio between the VLP-fraction and whole-community fraction. The idea is that contigs with a high amount of VLP-fraction read coverage relative to the whole-community fraction read coverage may be more likely to represent real transfer events rather than just contaminating DNA. If the VLP-fraction has a median read coverage at least half as great as the median read coverage in the whole-community fraction, then the contig is classified as having 'High VLP-fraction:Whole-community read coverage ratio'(HighVLPWCReadCov) rather than None. It is up to the user to decide if they would like to consider these classifications as Gen/Lat/GTA transducing events or simply exclude them.

-------------------------------------------------------------------------------------------------------------------------------------------

`TrIdentClassifier()` resizes the bins or 'windows' used by `pileup.sh` to improve processing time and reduce noise in the data. `TrIdentClassifier()` resizes windows to 1000 bp as a default. Depending on the dataset, the user may want to select a different `windowsize`. Users can choose between windowsizes of 200, 500, 1000 or 2000 **only**. We recommend increasing the `windowsize` to 2000 if processing speed is of importance or if data is noisy (i.e. VLP-fraction contaminated with external bacterial DNA). We recommend decreasing the `windowsize` if your data is very clean and/or **small** and you are interested in increasing the resolution of read coverage patterns for the initial classification of contigs.


To run `TrIdentClassifier()` in default-mode, run the following:

```{r}
#TrIdent_results <- TrIdentClassifier(phageread_dataset=VLPFraction_sampledata, microbial_readdataset=WholeCommunity_sampledata, windowsize = 1000, minblocksize=10000, maxblocksize=Inf, cleanup=TRUE)
```



The output of `TrIdentClassifier()` is a list containing five objects:

1.  Full_summary_table: A summary table containing the classification information for all contigs that were not filtered out.\
2.  Cleaned_summary_table: A cleaned summary table containing the classification information for all contigs classified as either Prophage-like or Gen/Lat/GTA (i.e. 'None classifications removed)
3.  PatternMatchInfo: A list of pattern-match info that is used by other functions in TrIdent.
4.  FilteredOutContig_table: A table of contigs that were filtered out and the reason why (either low read coverage or too short(\<30kbp)).
5.  Windowsize: The windowsize used.

Save the desired list-item to a new variable using its associated name:

```{r}
#TrIdent_summary_table <- TrIdent_results$Full_summary_table
```

```{r, echo=FALSE}
#kable(TrIdent_summary_table, caption="The TrIdentClassifier output summary table")
```

```{r}
#filteredout_contigs <- TrIdent_results$FilteredOutContig_table
```

```{r, echo=FALSE}
#kable(filteredout_contigs, caption="The TrIdentClassifier filtered-out contig summary table")
```

# Plot_TrIdentPatternMatches()

`Plot_TrIdentPatternMatches()` will output a list of read coverage plots of all contigs predicted as either Gen/Lat/GTA, Prophage-like, or HighVLPWCReadCov and their respective pattern matches.

```{r}
#TrIdent_patternmatches <- Plot_TrIdentPatternMatches(VLPFraction_sampledata, WholeCommunity_sampledata, TrIdent_results)
```

View either all plots at once or one plot at a time. Each plot is named by its respective contig accession. View all plots:

```{r eval=FALSE}
#TrIdent_patternmatches
```

```{r echo=FALSE}
#TrIdent_patternmatches$NODE_2
#TrIdent_patternmatches$NODE_44
#TrIdent_patternmatches$NODE_62
#TrIdent_patternmatches$NODE_125
#TrIdent_patternmatches$NODE_238
#TrIdent_patternmatches$NODE_251
#TrIdent_patternmatches$NODE_560
#TrIdent_patternmatches$NODE_1088
```

View one plot:

```{r}
#TrIdent_patternmatches$NODE_10
```

# SpecializedTransduction_ID()

Specialized transduction occurs when a prophage/PICI has an improper excision from the host bacterium's chromosome and accidentally packages a small portion of bacterial DNA directly outside the prophage/PICI region. `SpecializedTransduction_ID()` searches contigs classified as Prophage-like for dense read coverage outside the borders of the Prophage-like pattern that could represent specialized transduction. Because specialized transduction tends to be fairly short (several kbps) compared to generalized/lateral/gene transfer agent transduction (tens to hundreds of kbps), averaging over a 1000 bp distance (i.e using a `windowsize=1000`) can 'blur' specialized transduction patterns depending on their size. This is why specialized transduction is not identified in `TrIdent_Classifier()`. Instead, we use the locations of prophages/PICIs identified with `TrIdent_Classifier()` to guide our search for specialized transduction in `SpecializedTransduction_ID()`.

`SpecializedTransduction_ID()` does not resize the windows of the input pileup files to preserve resolution of potential specialized transduction patterns. Because of this, we can not use the locations of the Prophage-like pattern matches to determine the exact border locations of prophage/PICIs. The locations generated with `TrIdent_Classifier()` using a 1000 bp `windowsize` (or one of the other options) will not perfectly translate back to a `windowsize` of 100. Instead, we use the locations of the Prophage-like pattern matches to'zoom-in' on the region of a contig where an associated Prophage-like pattern match is located. `SpecializedTransduction_ID` then searches the contig, starting from the left moving inward, for the first coverage value that is at least 20% of the maximum coverage value. This represents the left 'border'. The search is repeated starting from the right side of the contig moving inwards and the first coverage value that is at least 20% of the maximum value represents the right 'border'. For contigs that have a Prophage-like match that trails off the side of a contig, then only the border that falls on the contig is searched for.

Once the prophage/PICI borders are identified, `SpecializedTransduction_ID()` starts from the borders and searches outwards for dense read coverage that meet the 'requirements' for specialized transduction as defined by the arguments in `SpecializedTransduction_ID()`. `SpecializedTRansducion_ID` uses two arguments to define specialized transduction:

-   `noreadcov`
-   `spectranslength`

`SpecializedTransduction_ID()` first makes sure that any coverage it detects outside the borders is not disrupted by a defined region of no read coverage (`noreadcov`). The default value for `noreadcov` is 500 bp. Secondly, `SpecializedTransduction_ID` ensures that any read coverage it detects outside of the prophage/PICI borders meets a minimum length requirement (`spectranslength`). The default value for `spectranslength` is 2000 bp. So by default, `SpecializedTransduction_ID()` will search for coverage that is at least 2000 bp long and is not interrupted at any point by more than 500 bp of no read coverage. If these requirements are met, `SpecializedTransduction_ID()` will mark the contig as having specialized transduction.

###### Default:

Search all contigs classified as Prophage-like for specialized transduction:

```{r}
#Specialized_transduction <- SpecializedTransduction_ID(VLPFraction_sampledata, TrIdent_results)
```

When you search all contigs, the output of `SpecializedTransduction_ID()` will be a list. The first object contains a summary table for the specialized transduction search results:

```{r}
#SpecializedTransduction_summary_table <- Specialized_transduction$Summary_table
```

```{r, echo=FALSE}
#kable(head(SpecializedTransduction_summary_table), format="html")
```

The second object in the output-list contains another list with the resulting **log 10** read coverage plots for all contigs classified as Prophage-like. The coverages are put in log-scale to help users visualize specialized transduction patterns as they are sometimes too low frequency to be seen with raw coverages. Additionally, the plots are 'zoomed-in' on the Prophage-like pattern to further aid with specialized transduction visualization. The borders of the prophage/PICI as identified by `SpecializedTransduction_ID()` are marked on each plot with a black vertical line. If `SpecializedTransduction_ID()` identifies potential specialized transduction, it will color the plot green whereas if does not identify any specialized transduction, it will color the plot blue. The end of specialized transduction as determined by `SpecializedTransduction_ID` will be marked with a red vertical line. Each plot is named by the associated contig accession.

View all the plots:

```{r eval=FALSE}
#Specialized_transduction$Plots
```

```{r echo=FALSE}
#Specialized_transduction$Plots$NODE_2
#Specialized_transduction$Plots$NODE_44
#Specialized_transduction$Plots$NODE_62
#Specialized_transduction$Plots$NODE_125
```

View a specific plot:

```{r}
#Specialized_transduction$Plots$NODE_2
```


 Create final summary table:

If you'd like to combine the summary tables produced by `TrIdentClassifier()` and `SpecializedTransduction_ID()`, try the following code:

```{r}
#Final_TrIdentSummaryTable <- merge(TrIdent_summary_table, SpecializedTransduction_summary_table, by="ref_name", all.x=TRUE)
```

```{r echo=FALSE}
#kable(Final_TrIdentSummaryTable)
```
