---
title: "TrIdent"
author: "Jessie Maier & Jorden Rabasco"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
description: >
  TrIdent (Transduction Identification) is a reference-independent tool for the automated detection, classification and characterization of transduction events in metagenomic sequence data. With only three functions, TrIdent is fast and user-friendly. Learn how to use TrIdent with a sample dataset here. 
vignette: >
  %\VignetteIndexEntry{Using TrIdent}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 9,
  fig.asp = 0.8,
  out.width = "80%",
  collapse = TRUE,
  comment = "##"
)
```

```{r setup, echo=FALSE, warning=FALSE}
library(TrIdent)
library(knitr)
library(patchwork)
library(ggplot2)
```

# Introduction

### **TrIdent**- **Tr**ansduction **Ident**ification

TrIdent is a reference-independent bioinformatics tool that automates the analysis of transductomics data by automatically detecting, classifying and characterizing potential transducing events in read coverage data. Transductomics is a DNA-sequencing based method for the detection and characterization of transduction events. Developed by Kleiner et al. (2020), transductomics relies on mapping reads from a virome (VLP-fraction) of a sample to contigs assembled from the metagenome (whole-community) of the same sample. Reads from bacterial DNA carried by viruses and other VLPs (Virus-like particles) will map back to the bacterial contigs of origin creating read coverage patterns indicative of potential ongoing transduction.

**Reference:** Kleiner, M., Bushnell, B., Sanderson, K.E. et al. Transductomics: sequencing-based detection and analysis of transduced DNA in pure cultures and microbial communities. Microbiome 8, 158 (2020). <https://doi.org/10.1186/s40168-020-00935-5>

TrIdent consists of three main functions to automatically detect, classify, and characterize potential transducing events:

-    `TrIdentClassifier()`: Classifies contigs as 'Prophage-like', 'Sloping', 'HighCovNoPattern', and 'NoPattern' using pattern-matching
-   `plotTrIdentResults()`: Plots pattern-matching results of `TrIdentClassifier()`
-   `specializedTransductionID()`:  searches contigs classified as Prophage-like by `TrIdentClassifier()` for potential specialized transduction

# Acknowledgments
TrIdent is the result of the combined effort and brain power of many individuals. Specifically, we would like to thank Dr. Manuel Kleiner, Dr. Ben Callahan, Dr. Breck Duerkop and Dr. Craig Gin for their individual expertise and overall support!

# Funding
The development of TrIdent was supported by a seed grant from the North Carolina State University Data Science Academy and by the 
National Institutes of Health under Award Number R35GM138362 and R01Al171046.

# Installation

## BioConductor install
```{r, eval=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("TrIdent")
library(TrIdent)
```

## GitHub install
```{r, eval=FALSE}
if (!require("devtools", quietly = TRUE))
    install.packages("devtools")

devtools::install_github("jlmaier12/TrIdent", ref="master")
library(TrIdent)
```
*NEEDS TO BE CHANGED TO MAIN BRANCH*

# Input Data

## Transductomics data
Transductomics allows for a glimpse into the 'transductome' (i.e the DNA being 'transduced') in a microbiome sample by identifying the bacterial DNA being actively carried by viral-like particles (VLPs). A transductomics dataset consists of two parts- a whole-community fraction and a VLP-fraction both originating from the same sample. The whole-community fraction is generated by extracting and sequencing DNA from the whole sample. The VLP-fraction is generated by first separating and ultra purifying the VLPs from the sample followed by DNA extraction and sequencing. Sequencing reads from the whole-community fraction are assembled and then both the whole-community and VLP-fraction reads are mapped to the assembly. **Read mapping should be performed using a high minimum identity (0.97 or higher) and random mapping of ambiguous reads.**  The pileup files needed for TrIdent are generated using using bam files produced during read mapping. More information on pileup files in next section. 

### Example transductomics data generation workflow:
Generating transductomics data from a conventional mouse fecal metagenome: 
-     Homogenized feces represents the whole-community fraction. 
-     The VLP-fraction of the fecal homogenate is separated with 0.2 um filtration to remove bacterial cells, treated with DNase to remove free DNA and ultrapurified via CsCl density gradient ultracentrifugation.
-     Both the whole-community and VLP-fraction are sequenced with Illumina (paired-end mode, 150 bp reads).
-     Sequencing reads are decontaminated from host sequences and trimmed to remove adapters and low quality sequences.
-     The metagenome is assembled from the whole-community reads and filtered to remove contigs less that 30,000 bp (min. contig size for TrIdent).
-     The whole-community and VLP-fraction raw reads are mapped to the metagenome assembly to create two separate bam files.
-     The bam files are used to create two pileup .txt files.

Note- A high sequencing depth of the VLP-fraction is required for transductomics! Sample preparation and sequencing procedures are detailed in Kleiner et al. (2020).

## Pileup files

TrIdent classifies mapped read coverage patterns using a pattern-matching algorithm that operates on pileup files. A pileup file is a file format where each row summarizes the 'pileup' of reads at specific genomic locations. We take advantage of the fact that pileup files can be used to generate a rolling mean of read coverages and associated base pair positions across a metagenome assembly, effectively summarizing the read coverage patterns across contigs while reducing the overall size of the dataset. **TrIdent requires that pileups files be produced using a 100 bp window/bin size.**  

Some read mappers, like [BBMap](https://github.com/BioInfoTools/BBMap/blob/master/sh/bbmap.sh), will allow for the generation of pileup files in the `bbmap.sh` command with the use of the `bincov` output with the `covbinsize=100` parameter. Otherwise, [BBMap](https://github.com/BioInfoTools/BBMap/blob/master/sh/pileup.sh) `pileup.sh` with the `bincov` output and `binsize=100` parameter can convert bam files produced by any read mapper to pileup files compatible with TrIdent.

TrIdent requires two separate pileup files for input:

-     A VLP-fraction pileup: Sequencing reads from a sample's VLP-fraction mapped to a metagenome assembly from the same sample.
-     A whole-community pileup: Sequencing reads from a sample's whole-community mapped to the metagenome of the same sample. 

**Remember- The data used for each pileup file must originate from the same sample. Pileup files must use a 100 bp window/bin size for the rolling mean.** 

Here is how the input pileup files should look. The information in the first column may be formatted differently depending on your contig accession format:
```{r echo=FALSE}
data(WholeCommunitySamplePileup)
data(VLPFractionSamplePileup)
print(head(VLPFractionSamplePileup), row.names=FALSE)
```

TrIdent has built-in data cleaning and reformatting. **If you do not use BBMap's `pileup.sh` to generate the pileup files, then you are responsible for data-cleaning and reformatting.** Your pileup files must be in the following format (same column names, same column classes, etc.) and you must use the `cleanup=FALSE` argument for the `TrIdent_classifier()`, `Plot_TrIdentPatternMatches()`, and `SpecializedTransduction_ID()`.
```{r, echo=FALSE}
data(CleanVLPFractionSamplePileup)
print(head(CleanVLPFractionSamplePileup), row.names=FALSE)
```

# Quick Start

Here is how to run TrIdent with default parameters. TrIdent involves the use of three functions that are used in the following order:
```{r}
#Run first
TrIdentOutput <- TrIdentClassifier(VLPpileup=VLPFractionSamplePileup, 
                                   WCpileup=WholeCommunitySamplePileup)
```

```{r}
#Run second
TrIdentPlots <- plotTrIdentResults(VLPpileup=VLPFractionSamplePileup, 
                                   WCpileup=WholeCommunitySamplePileup, 
                                   TrIdentResults=TrIdentOutput)

#Run last
SpecTransduction <- specializedTransductionID(VLPpileup=VLPFractionSamplePileup, 
                                              TrIdentResults=TrIdentOutput)
```


Additional information for each of these functions are provided in the following sections.

# TrIdentClassifier()

`TrIdentClassifier()` is the main function in TrIdent. This function cleans and reformats your input data, filters contigs based on length and read 
coverage, performs pattern-matching to classify contigs, identifies active/highly abundant and heterogenously integrated Prophage-like elements, 
determines which contigs have high VLP-fraction:whole-community read coverage ratios, identifies start and stop positions and sizes of 
pattern-matches, calculates slopes for Sloping pattern matches, generates a pattern-match quality score and outputs all information in a neat 
summary table.

## Contig filtering
Contigs are filtered out based on short length or low read coverage. TrIdent filters out contigs that do not have at least 10x coverage on a total 
of 5,000 bp across the whole contig. The read coverage filtering was done in this way to avoid filtering out long contigs with short Prophage-like 
patterns that might get removed if filtering was done with averages or medians. Additionally, contigs less than 30 kbp are filtered out by default, 
however this can be changed with the `minContigLength` parameter. Contigs shorter than 30 kbp may be poor quality and are often not long enough to 
capture complete transduction patterns. If you would like to speed-up processing time of TrIdent, consider pre-filtering your assembly for contigs 
greater than 30 kbp prior to read mapping!

## Pattern-matching
TrIdent detects read coverage patterns in the VLP-fraction using a pattern-matching approach. Several predefined patterns, described below, are 
built using the specific length and read coverage values of the contig being assessed. Patterns are translated across each contig 1,000 bp at a time
and at each translation, a pattern-match score is calculated by taking the mean absolute difference of the VLP-fraction read coverage and the
pattern values. The smaller the match-score, the better the pattern-match. After a pattern is fully translated across a
contig, certain aspects of the pattern are changed (i.e. height, width, slope) and translation is repeated. This process of
translation and pattern re-scaling is repeated until a wide variety of height, width and slope combinations are tested for
each pattern variation. After pattern-matching is complete, the pattern associated with the best match-score is used for
contig classification. Contigs are classified as ‘Prophage-like’, ‘Sloping’, ‘HighCovNoPattern' or 'NoPattern'. 

### Patterns

-   **Sloping:** There are four sloping pattern variations in the Sloping class. The sloping patterns are representative of large DNA transfers that take place during generalized, lateral and gene transfer agents (GTAs) due to the decreasing frequency of DNA packaging moving away from the packaging initiation sites. During pattern-matching, the slope values of the sloping patterns are decreased until a minimum slope of 0.001 (change of 10x read coverage over 10,000 bp) is reached. The minimum slope value can be changed with the `minSlope` parameter. Generalized, lateral and GTA transduction events can span many kbps of DNA and a single contig typically does not capture an entire event. Depending on which part of the transducing event is captured by the contig, the sloping can be very severe or almost 0. Patterns 1 and 2 represent contigs that capture a Sloping transducing event somewhere in the middle of the DNA transfer. Patterns 2 and 4 represent contigs that capture the packaging initiation of a Sloping transducing event. Patterns 2 and 4 are translated across the contig in addition to having the slopes changed while only the slopes are changed on patterns 1 and 2.

```{r echo=FALSE}

dataframe <- cbind.data.frame(c(1:100), c(seq(1,100,1)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL, title="Pattern 1")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(seq(100,1,-1)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot2 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL,title="Pattern 2")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(rep(0,20),seq(80,1,-1)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot3 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL, title="Pattern 3")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
  )

dataframe <- cbind.data.frame(c(1:100), c(seq(1,80,1), rep(0,20)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot4 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
  labs(x=NULL,y=NULL, title="Pattern 4")+
  theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )


plot1+plot2+plot3+plot4
```

-   **Prophage-like:**

There are three block patterns in the Prophage-like class. The block patterns are representative of integrated genetic elements that can be excised from the host chromosome and mobilized. The blocks of read coverage that define this classification are formed when the reads of mobilized genetic elements map back to their respective integration sites in the host bacterium's chromosome. Prophage, phage-inducible chromosomal islands (PICIs), and transposons are all examples of genetic elements that fall into the Prophage-like class. While a Prophage-like classification is not an example of transduction, there may be transduction associated with Prophage-like classifications. The improper excision of integrated genetic elements may lead to the specialized transduction of genes neighboring the integration site. TrIdent's `specializedTransductionID()` function (explained in detail below) will attempt to detect specialized transduction events associated with Prophage-like classifications. The block pattern heights are decreased followed by the block's width to ensure a variety of block height/width combinations are tested. Each pattern variation is translated across the contig. The blocks widths never get smaller than 10kbp however this can be changed with the `minBlockSize` parameter. Pattern 1 represents a Prophage-like element that is entirely on the contig while patterns 2 and 3 repesent Prophage-like elements that trail off the right or left side of the contig, respectively.

```{r echo=FALSE}
dataframe <- cbind.data.frame(c(1:100), c(rep(0,20), rep(100,60), rep(0,20)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL,title="Pattern 1")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(rep(0,60), rep(100,40)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot2 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL,title="Pattern 2")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

dataframe <- cbind.data.frame(c(1:100), c(rep(100,40), rep(0,60)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot3 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
    labs(x=NULL,y=NULL, title="Pattern 3")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

plot1+plot2+plot3
```

-   **noPattern:**

Since the best pattern-match is determined by comparing match-scores amongst all pattern-variations, we needed a ‘negative control’ pattern to match read coverage patterns on contigs with no read coverage patterns. We made two ‘NoPattern’ 'patterns' which consist of a horizontal line the same length as the contig being assessed. The no transduction patterns are vectors of values that equal either the average or median read coverage for a contig. This pattern is not altered or translated in any way. Note that read coverage patterns are heavily dependent on the depth of read coverage achieved during sequencing and therefore very low abundant transduction events may not achieve sufficient read coverage for detection with read coverage pattern-matching. Rather than label contigs as having ‘no transduction’, we instead label them as having NoPattern.

```{r echo=FALSE}
dataframe <- cbind.data.frame(c(1:100), rep(10,100))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x=mockpos, y=mockcov))+
  geom_line(linewidth=2)+
  ylim(0,100)+
    labs(x=NULL,y=NULL, title="Pattern 1")+
    theme_classic()+
  ggplot2::theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
         panel.border = element_rect(colour = "black", fill=NA, linewidth=2)
        )

plot1
```

-------------------------------------------------------------------------------------------------------------------------------------------

## Highly active/abundant and heterogenously integrated/present Prophage-like elements

We refer to mobile genetic elements that are packaged by VLPs, like prophage and PICIs, for example, as 'Prophage-like elements'. Prophage-like 
elements that are actively replicating or exist in high abundance in the environment will typically generate more sequencing reads than the 
non-mobile regions of the host bacterium's chromosome. This may create a region of elevated read coverage at the element's insertion site in the 
whole-community fraction. Conversely, if a Prophage-like element is integrated into only a portion of the host bacterial population, there may be a 
dip or depression in read coverage at the integration site. Since TrIdent locates Prophage-like elements in the VLP-fraction read coverage****, we 
can use the genomic coordinates to see if the associated Prophage-like region has elevated read coverage in the whole-community fraction. Contigs 
where the Prophage-like:non-Prophage-like region has a mean read coverage ratio of greater than 1.15 are labeled as 'elevated' while ratios less 
then 0.75 are labeled as 'depressed'. If the non-Prophage-like region is less than 20,000 bp, then the contig is labeled as 'CBD' (Can't Be 
Determined) as it's difficult to determine if the Prophage-like region is elevated or depressed when there is relatively little non-Prophage-like 
read coverage to compare to.

## NoPattern with high VLP-fraction:whole-community read coverage ratio

If a contig receives a noPattern classification, it proceeds to an additional classification step which either leaves the classification as is or 
re-classifies the contig as having high read coverage in the VLP-fraction but no read coverage pattern (‘HighCovNoPattern’). This re-classification 
is necessary because certain transduction events, specifically generalized and lateral events, may be so long that they extend across multiple 
contigs. The ‘tails’ of the sloping patterns created by these events may appear as even read coverage that spans the contig with little to no actual
sloping. Additionally, there is evidence that membrane vesicle (MV) mediated transduction (also known as vesiduction or protected extracellular 
transformation) produces even read coverage patterns when purified MV sequencing reads are mapped back to their bacterial chromosome of origin.** We
differentiate contigs with noPattern classifications that may represent transduction events from low-level contamination using the 
VLP-fraction to whole-community median read coverage ratio. Contigs with median VLP-fraction:Whole-community read coverage ratios greater than 2, in
other words contigs with where the median VLP-fraction read coverage value is twice as great as the whole-community median read coverage value, are 
re-classified as HighCovNoPattern. It is up to the user to decide if they would like to consider these classifications as potential transduction events or simply exclude them.

-------------------------------------------------------------------------------------------------------------------------------------------

## Parameters

```{r eval=FALSE}
TrIdentClassifier(VLPpileup, WCpileup, windowSize=1000, minBlockSize=10000,
                   maxBlockSize=Inf, minContigLength=30000, minSlope=0.001,
                   suggFiltThresh=FALSE, SaveFilesTo, cleanup=TRUE)
```

-     `VLPpileup` 
-     `WCpileup`
-     `windowSize`
-     `minBlockSize`
-     `maxBlockSize`
-     `minContigLength`
-     `minSlope`
-     `suggFiltThresh`
-     `SaveFilesTo`
-     `cleanup`


`TrIdentClassifier()` resizes the bins or 'windows' used by `pileup.sh` to improve processing time and reduce noise in the data. `TrIdentClassifier()` resizes windows to 1000 bp as a default. Depending on the dataset, the user may want to select a different `windowsize`. Users can choose between windowsizes of 200, 500, 1000 or 2000 **only**. We recommend increasing the `windowsize` to 2000 if processing speed is of importance or if data is noisy (i.e. VLP-fraction contaminated with external bacterial DNA). We recommend decreasing the `windowsize` if your data is very clean and/or **small** and you are interested in increasing the resolution of read coverage patterns for the initial classification of contigs.

## Output

The output of `TrIdentClassifier()` is a list containing five objects:

1.  SummaryTable: A summary table containing the classification information for all contigs that were not filtered out.
2.  CleanedSummaryTable: A cleaned summary table containing the classification information for all contigs classified as Prophage-like, Sloping and HighCovNoPattern.
3.  PatternMatchInfo: A list of pattern-match info that is used by other functions in TrIdent.
4.  FilteredOutContigTable: A table of contigs that were filtered out and the reason why (either low read coverage or too short(\<30kbp)).
5.  windowSize: The `windowSize` used.

Save the desired list-item to a new variable using its associated name:

```{r}
TrIdentSummaryTable <- TrIdentOutput$SummaryTable
```

```{r, echo=FALSE}
kable(TrIdentSummaryTable, caption="The TrIdentClassifier() output summary table")
```

```{r}
FilteredOutContigs <- TrIdentOutput$FilteredOutContigTable
```

```{r, echo=FALSE}
kable(FilteredOutContigs, caption="The TrIdentClassifier() filtered-out contig summary table")
```

# plotTrIdentResults()

`plotTrIdentResults()` will output a list of read coverage plots of all contigs classified as Sloping, Prophage-like, or HighCovNoPattern and their respective pattern matches.

## Parameters

`plotTrIdentResults(VLPpileup, WCpileup, TrIdentResults, matchScoreFilter,` 
                   `saveFilesTo, cleanup=TRUE)`

-    `VLPpileup`
-    `WCpileup`
-    `TrIdentResults`
-    `matchScoreFilter`
-    `saveFilesTo`
-    `cleanup`


## Output

The output of `plotTrIdentResults()` is a list containing ggplot objects.


View either all plots at once or one plot at a time. Each plot is named by its respective contig accession. View all plots:

```{r eval=FALSE}
#TrIdentPlots
```

```{r echo=FALSE}
#TrIdentPlots$NODE_62
#TrIdentPlots$NODE_135
#TrIdentPlots$NODE_1088
#TrIdentPlots$NODE_352
#TrIdentPlots$NODE_368
#TrIdentPlots$NODE_560
#TrIdentPlots$NODE_617
#TrIdentPlots$NODE_2060
```

View one plot:

```{r}
TrIdentPlots$NODE_62
```

# specializedTransductionID()

## Parameters

`specializedTransductionID(VLPpileup, TrIdentResults, specificContig, noReadCov=500,` 
                          `specTransLength=2000, matchScoreFilter=Inf, logScale=FALSE, cleanup=TRUE)`

-    `VLPpileup`
-    `TrIdentResults`
-    `specificContig`
-    `noReadCov`
-    `specTransLength` 
-    `matchScoreFilter`
-    `logScale`
-    `cleanup`

## Output

Specialized transduction occurs when a Prophage-like has an improper excision from the host bacterium's chromosome and accidentally packages a small portion of bacterial DNA directly outside the Prophage-like region. `specializedTransductionID()` searches contigs classified as Prophage-like for dense read coverage outside the borders of the Prophage-like pattern that could represent specialized transduction. Because specialized transduction tends to be fairly short (several kbps) compared to generalized/lateral/gene transfer agent transduction (tens to hundreds of kbps), averaging over a 1000 bp distance (i.e using a `windowsize=1000`) can 'blur' specialized transduction patterns depending on their size. This is why specialized transduction is not identified in `TrIdentClassifier()`. Instead, we use the locations of prophages/PICIs identified with `TrIdentClassifier()` to guide our search for specialized transduction in `specializedTransductionID()`.

`specializedTransductionID()` does not resize the windows of the input pileup files to preserve resolution of potential specialized transduction patterns. Because of this, we can not use the locations of the Prophage-like pattern matches to determine the exact border locations of prophage/PICIs. The locations generated with `TrIdentClassifier()` using a 1000 bp `windowsize` (or one of the other options) will not perfectly translate back to a `windowsize` of 100. Instead, we use the locations of the Prophage-like pattern matches to'zoom-in' on the region of a contig where an associated Prophage-like pattern match is located. `specializedTransductionID` then searches the contig, starting from the left moving inward, for the first coverage value that is at least 20% of the maximum coverage value. This represents the left 'border'. The search is repeated starting from the right side of the contig moving inwards and the first coverage value that is at least 20% of the maximum value represents the right 'border'. For contigs that have a Prophage-like match that trails off the side of a contig, then only the border that falls on the contig is searched for.

Once the prophage/PICI borders are identified, `SpecializedTransduction_ID()` starts from the borders and searches outwards for dense read coverage that meet the 'requirements' for specialized transduction as defined by the arguments in `SpecializedTransduction_ID()`. `SpecializedTRansducion_ID` uses two arguments to define specialized transduction:

-   `noreadcov`
-   `spectranslength`

`SpecializedTransduction_ID()` first makes sure that any coverage it detects outside the borders is not disrupted by a defined region of no read coverage (`noreadcov`). The default value for `noreadcov` is 500 bp. Secondly, `SpecializedTransduction_ID` ensures that any read coverage it detects outside of the prophage/PICI borders meets a minimum length requirement (`spectranslength`). The default value for `spectranslength` is 2000 bp. So by default, `SpecializedTransduction_ID()` will search for coverage that is at least 2000 bp long and is not interrupted at any point by more than 500 bp of no read coverage. If these requirements are met, `SpecializedTransduction_ID()` will mark the contig as having specialized transduction.


When you search all contigs, the output of `SpecializedTransduction_ID()` will be a list. The first object contains a summary table for the specialized transduction search results:

```{r}
SpecializedTransducSummaryTable <- SpecTransduction$summaryTable
```

```{r, echo=FALSE}
kable(head(SpecializedTransducSummaryTable), format="html")
```

The second object in the output-list contains another list with the resulting **log 10** read coverage plots for all contigs classified as Prophage-like. The coverages are put in log-scale to help users visualize specialized transduction patterns as they are sometimes too low frequency to be seen with raw coverages. Additionally, the plots are 'zoomed-in' on the Prophage-like pattern to further aid with specialized transduction visualization. The borders of the prophage/PICI as identified by `SpecializedTransduction_ID()` are marked on each plot with a black vertical line. If `SpecializedTransduction_ID()` identifies potential specialized transduction, it will color the plot green whereas if does not identify any specialized transduction, it will color the plot blue. The end of specialized transduction as determined by `SpecializedTransduction_ID` will be marked with a red vertical line. Each plot is named by the associated contig accession.

View all the plots:

```{r eval=FALSE}
#SpecTransduction$Plots
```

```{r echo=FALSE}
SpecTransduction$Plots$NODE_368
SpecTransduction$Plots$NODE_135
SpecTransduction$Plots$NODE_62
SpecTransduction$Plots$NODE_617
```

View a specific plot:
```{r}
SpecTransduction$Plots$NODE_62
```


# Generate final summary table

If you'd like to combine the summary tables produced by `TrIdentClassifier()` and `specializedTransductionID()`, try the following code:

```{r}
FinalTrIdentSummaryTable <- merge(TrIdentSummaryTable, SpecializedTransducSummaryTable, by="contigName", all.x=TRUE)
```

```{r echo=FALSE}
kable(FinalTrIdentSummaryTable)
```

# Session Information

```{r}
sessionInfo()
```

